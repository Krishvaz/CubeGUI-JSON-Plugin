---
title: Syntax Trees and Syntax Analysis
short_title: Syntax Trees and Syntax Analysis
kind: quiz
prefix: '023'
hidden: false
---

## Introduction

Trees are used to represent *hierarchically* structured data. In many applications, the structure is defined by a **grammar**, which determines the **syntax** of the data. We use simple terms of arithmetic expressions as an example. Other examples include documents (HTML, XML, ...). Even the notation of an algorithm or program in a programming language follows a predefined syntax. (That's nothing more than our example with terms – just more complex!)

We write grammars in Backus-Naur Form (BNF). Strings in quotes (e.g., `"+"`) and `< number >` are **terminals** (or **terminal symbols**). (Spaces before/after angle brackets are just for correct HTML display.)

### q:{}

This means:

- [ ] Terminals will later become leaves in the tree. :: Operators, for example, are inner nodes. "Terminal" here refers to the grammar.
- [X] There are no production rules for terminals. :: Because they are the smallest units "at the end".
- [X] Terminals are generated in lexical analysis.

### q:{}

Lexical analysis

- [X] is a preprocessing step :: So we don’t necessarily have to deal with individual characters of the input, but instead get tokens like numbers and symbols (e.g., variable names).
- [X] is also a syntax analysis :: However, it uses a much simpler grammar (usually so-called *regular expressions*) that doesn't allow "nesting" (e.g., parentheses). Example of a rule: a sequence of digits is a number. (There’s no need to blow up the BNF with that.)
- [X] breaks the input into a sequence of parts. :: These are often called *tokens*.
- [X] produces the terminals in the BNF.
- [X] can ignore filler characters (e.g., *whitespace* like spaces) in the input. :: It may also be suitable to handle or ignore comments here.

### q:{}

Which of the following expressions can be generated by the given grammar?

```pascal
< sum > ::= < number > "+" < number >
```

- [X] `1+2`
- [X] `12+34`
- [ ] `1-2`
- [ ] `1+2+3`
- [ ] `(1+2)+3`

### q:{}

Which of the following expressions can be generated by the given grammar?

```pascal
< sum > ::= < number > | < number > "+" < sum >
```

- [X] `1`
- [X] `1+2`
- [X] `12+34`
- [ ] `1-2`
- [X] `1+2+3`
- [X] `1+2+3+4`
- [ ] `(1+2)+3`

### q:{}

What if we shorten the rules like this?

```pascal
< sum > ::= < number > "+" < sum >
```

- [ ] All good, it’s on the slides. :: That’s why there's a `...` ;-)
- [X] The rule is *recursively defined*, but the recursion never ends! :: Understand how recursion or recursive rule application works!

### q:{}

Which of the following expressions can be generated by the given grammar?

```pascal
< sum >     ::= < product > | < product > "+" < sum >
< product > ::= < factor >  | < factor >  "*" < product >
< factor >  ::= < number >
```

- [X] `1`
- [X] `1*2+3`
- [X] `1+2*3`
- [X] `1*2`
- [ ] `(1+2)*3`

### q:{}

Which of the following expressions can be generated by the given grammar?

```pascal
< sum >     ::= < product > | < product > "+" < sum >
< product > ::= < factor >  | < factor >  "*" < product >
< factor >  ::= < number >  | "(" < sum > ")"
```

- [X] `1`
- [ ] `-1`
- [X] `1*2+3`
- [X] `1+2*3`
- [X] `1*2`
- [X] `(1+2)*3`
- [X] `(1*3)+3`

### q:{}

Syntax analysis is done by

- [ ] the *lexical scanner*
- [X] the parser :: From *to parse* = to break down...

## Code Examples

We consider syntax analysis by *recursive descent*: a [recursive descent parser]. There are many other methods and algorithms. This is probably the simplest, especially if you’re implementing the parser yourself (without code generators): the code is relatively simple, human-readable, and extendable — e.g., when the grammar expands. That doesn’t mean it’s easy overall... take your time and study the examples.

[recursive descent parser]: http://en.wikipedia.org/wiki/Recursive_descent_parser

### q:{}

The class `ExpressionTree`

- [ ] implements the parser
- [X] represents the result of the syntax analysis :: As a tree.

### q:{}

The class `ExpressionParser`

- [X] implements the rules of the BNF as methods :: Almost "1:1".
- [X] handles syntax errors :: Such an error occurs when no rule can be applied. I.e., a specific *token* is expected from the *lexical scanner*, but it's not there. **Exceptions** are ideal here to abort the recursive analysis.
- [X] creates an `ExpressionTree`

### q:{}

The class `ExpressionParser` "communicates" with the *lexical scanner* using the methods

- [ ] `sum`
- [ ] `factor`
- [ ] `number`
- [X] `lookahead` :: `lookahead` returns the current token without consuming it: it remains "current". We need this method to decide which rule to apply.
- [X] `nextToken` :: `nextToken` consumes the current token, i.e., reads the next token as the new `lookahead`

## Finally

There are many other ways and algorithms to implement parsers.

In the book by *Saake and Sattler* or *Sedgewick* (newer version — older ones cover recursive descent), you’ll find Dijkstra's *2-stack* or [shunting-yard][shunting-yard] algorithm.

### q:{}

Which statements are true?

- [X] The algorithm uses two stacks.
- [X] The algorithm analyzes expressions in infix notation. :: It is explicitly designed for this.
- [ ] The algorithm is much simpler. :: Maybe, maybe not. That’s a matter of opinion. It might be simpler because it’s designed for a very specific task (parsing infix notation) and aligns better with our "first intuition". But it might not be as easily extendable for more complex tasks as recursive descent parsing. (But there’s nothing wrong with combining both approaches.)

[shunting-yard]: https://en.wikipedia.org/wiki/Shunting-yard_algorithm

*Note:* If you modify these algorithms to read terms in reverse Polish notation — i.e., different syntax! — you’ll quickly see that one of the stacks is no longer needed.

{:comment
%%% Local Variables:
%%% ispell-local-dictionary: "de"
%%% coding: utf-8
%%% End:
}
